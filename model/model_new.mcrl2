sort
  Place      = struct RI | RO | S1 | S2 | I | O | P;
  Door       = struct outsideDoor | insideDoor;
  Sluice     = struct sluice1 | sluice2;
  Pressure   = struct vacuum | normal;
  Status = struct empty | projected | unprojected | stuck;

map
  sluicePlace: Sluice -> Place;
  placesEmpty: Place -> Status;
  placesFalse: Place -> Bool;

  % Only used for model checking
  doorsFalse: Door -> Bool;
  sluiceDoorsFalse: Sluice -> (Door -> Bool);

var
  place: Place;
  sluice: Sluice;
  door: Door;

eqn
  sluicePlace(sluice1) = S1;
  sluicePlace(sluice2) = S2;

  placesEmpty(place) = empty;
  placesFalse(place) = false;

  % Only used for model checking
  doorsFalse(door) = false;
  sluiceDoorsFalse(sluice) = doorsFalse;

act
  % external actions
  move: Place # Place;
  closeDoor, openDoor, doorStuck: Door # Sluice;
  vacuum, deVacuum, stopPumping: Sluice;
  readAirPressure: Sluice # Pressure;
  beginProject, endProject, detectInputWafer;

  % communication actions (s = send, r = receive, c = communicate)
  sStatusUpdateRequest, rStatusUpdateRequest, cStatusUpdateRequest: Place # Status;
  sStatusUpdateResponse, rStatusUpdateResponse, cStatusUpdateResponse: Place # Status;
  sMoveRequest, rMoveRequest, cMoveRequest: Place # Place # Status;
  sMoveResponse, rMoveResponse, cMoveResponse: Place # Place;
  sMoveCancel, rMoveCancel, cMoveCancel: Place # Place;
  sSluiceRequest, rSluiceRequest, cSluiceRequest: Sluice # Door # Place;
  sSluiceResponse, rSluiceResponse, cSluiceResponse: Sluice # Door # Place;
  sSluiceFailedResponse, rSluiceFailedResponse, cSluiceFailedResponse: Sluice # Door # Place;
  sSluiceMoveDone, rSluiceMoveDone, cSluiceMoveDone: Sluice # Door;
  sSluiceStuck, rSluiceStuck, cSluiceStuck: Sluice # Bool # Bool;

proc
  WaferTracker(status: Place -> Status, locked: Place -> Bool)
    = sum a, b: Place, s, t: Status . ((!locked(a) && !locked(b) && status(a) == s && status(b) == empty
                                            && (((exists s: Sluice . sluicePlace(s) == b) && status(a) == unprojected)
                                                => (status(I) == empty && (forall s: Sluice . (status(sluicePlace(s)) != unprojected || sluicePlace(s) == a)))
                                               )
                                            && (((exists s: Sluice . sluicePlace(s) == b) && status(a) == projected)
                                                => (forall s: Sluice . (status(sluicePlace(s)) != projected || sluicePlace(s) == a))
                                               )
                                           ) -> rMoveRequest(a, b, s) . WaferTracker(status, locked[a -> true][b -> true])
                                           + (locked(a) && locked(b)) -> (sMoveResponse(a, b) . WaferTracker(status[b -> status(a)][a -> empty], locked[a -> false][b -> false])
                                                                          + rMoveCancel(a, b) . WaferTracker(status, locked[a -> false][b -> false])
                                                                         )
                                           + (!locked(a) && status(a) == s) -> rStatusUpdateRequest(a, s).WaferTracker(status, locked[a -> true])
                                           + locked(a) -> sStatusUpdateResponse(a, s).WaferTracker(status[a -> s], locked[a -> false])
                                          );

  RobotOutside(limited: Bool, limit: Int, repeat: Bool)
    = (limit > 0 || !limited) -> sStatusUpdateRequest(RI, empty) . detectInputWafer . rStatusUpdateResponse(RI, unprojected) . RobotOutside(limit = if(limited, limit - 1, limit))
      + sStatusUpdateRequest(RO, projected) . rStatusUpdateResponse(RO, empty) . RobotOutside(limit = if(limited && repeat, limit + 1, limit))
      + (MoveToSluice(RI, outsideDoor, unprojected)
         + MoveFromSluice(RO, outsideDoor, projected)
         + MoveFromSluiceToSluice(outsideDoor, unprojected)
        ) . RobotOutside();

  RobotInside
    = (MoveToSluice(O, insideDoor, projected)
       + MoveFromSluice(I, insideDoor, unprojected)
       + MoveFromSluiceToSluice(insideDoor, projected)
      ) . RobotInside;

  MoveToSluice(place: Place, door: Door, status: Status)
    = sum s:Sluice . ((sMoveRequest(place, sluicePlace(s), status) | sSluiceRequest(s, door, place))
                      + rSluiceResponse(s, door, place)
                      . move(place, sluicePlace(s))
                      . (rMoveResponse(place, sluicePlace(s)) | sSluiceMoveDone(s, door))
                      + rSluiceFailedResponse(s, door, place)
                      . sMoveCancel(place, sluicePlace(s))
                     );

  MoveFromSluice(place: Place, door: Door, status: Status)
    = sum s: Sluice . ((sMoveRequest(sluicePlace(s), place, status) | sSluiceRequest(s, door, place))
                        + rSluiceResponse(s, door, place)
                        . move(sluicePlace(s), place)
                        . (rMoveResponse(sluicePlace(s), place) | sSluiceMoveDone(s, door))
                        + rSluiceFailedResponse(s, door, place)
                        . sMoveCancel(sluicePlace(s), place)
                      );

  MoveFromSluiceToSluice(door: Door, status: Status)
    = sum s, t: Sluice . ((sMoveRequest(sluicePlace(t), sluicePlace(s), status) | sSluiceRequest(s, door, sluicePlace(t)) | sSluiceStuck(t, door == outsideDoor, door == insideDoor))
                          + rSluiceResponse(s, door, sluicePlace(t))
                          . move(sluicePlace(t), sluicePlace(s))
                          . (rMoveResponse(sluicePlace(t), sluicePlace(s)) | sSluiceMoveDone(s, door))
                          + rSluiceFailedResponse(s, door, sluicePlace(t))
                          . sMoveCancel(sluicePlace(t), sluicePlace(s))
                         );

  ProjectorRobot
    = (sMoveRequest(I, P, unprojected) . move(I, P) . rMoveResponse(I, P)
       + sMoveRequest(P, O, projected) . move(P, O) . rMoveResponse(P, O)
       + sStatusUpdateRequest(P, unprojected) . beginProject . endProject . rStatusUpdateResponse(P, projected)
      ) . ProjectorRobot;


  Sluice(sluice: Sluice, outsideOpen: Bool, insideOpen: Bool, outsideStuck: Bool, insideStuck: Bool)
    = (outsideStuck && !outsideOpen && !insideStuck && !insideOpen)
      -> vacuum(sluice)
          . readAirPressure(sluice, vacuum)
          . stopPumping(sluice)
          . (openDoor(insideDoor, sluice) . Sluice(insideOpen = true)
              + doorStuck(insideDoor, sluice) . Sluice(insideStuck = true)
            )
    + (insideStuck && !insideOpen && !outsideStuck && !outsideOpen)
      -> deVacuum(sluice)
          . readAirPressure(sluice, normal)
          . stopPumping(sluice)
          . (openDoor(outsideDoor, sluice) . Sluice(outsideOpen = true)
              + doorStuck(outsideDoor, sluice) . Sluice(outsideStuck = true)
            )
    + (insideStuck || outsideStuck) -> rSluiceStuck(sluice, outsideOpen, insideOpen) . Sluice()
    + (insideStuck && outsideStuck && !insideOpen && !outsideOpen) -> (sStatusUpdateRequest(sluicePlace(sluice), projected)
                                                                        + sStatusUpdateRequest(sluicePlace(sluice), unprojected)
                                                                      ) . rStatusUpdateResponse(sluicePlace(sluice), stuck) . Sluice()
    + (!insideStuck && !outsideStuck)
      ->
      sum p: Place . (rSluiceRequest(sluice, outsideDoor, p)
                      . (outsideOpen -> (sSluiceResponse(sluice, outsideDoor, p)
                                          . rSluiceMoveDone(sluice, outsideDoor)
                                          . Sluice()
                                        )
                                     <> (closeDoor(insideDoor, sluice)
                                          . deVacuum(sluice)
                                          . readAirPressure(sluice, normal)
                                          . stopPumping(sluice)
                                          . (openDoor(outsideDoor, sluice)
                                              . sSluiceResponse(sluice, outsideDoor, p)
                                              . rSluiceMoveDone(sluice, outsideDoor)
                                              . Sluice(outsideOpen = true, insideOpen = false)
                                              + doorStuck(outsideDoor, sluice)
                                              . sSluiceFailedResponse(sluice, outsideDoor, p)
                                              . Sluice(insideOpen = false, outsideStuck = true)
                                            )
                                          + doorStuck(insideDoor, sluice)
                                          . sSluiceFailedResponse(sluice, outsideDoor, p)
                                          . Sluice(insideStuck = true)
                                        )
                        )
                      +
                      rSluiceRequest(sluice, insideDoor, p)
                      . (insideOpen -> (sSluiceResponse(sluice, insideDoor, p)
                                          . rSluiceMoveDone(sluice, insideDoor)
                                          . Sluice()
                                        )
                                     <> (closeDoor(outsideDoor, sluice)
                                          . vacuum(sluice)
                                          . readAirPressure(sluice, vacuum)
                                          . stopPumping(sluice)
                                          . (openDoor(insideDoor, sluice)
                                              . sSluiceResponse(sluice, insideDoor, p)
                                              . rSluiceMoveDone(sluice, insideDoor)
                                              . Sluice(outsideOpen = false, insideOpen = true)
                                              + doorStuck(insideDoor, sluice)
                                              . sSluiceFailedResponse(sluice, insideDoor, p)
                                              . Sluice(outsideOpen = false, insideStuck = true)
                                            )
                                          + doorStuck(outsideDoor, sluice)
                                          . sSluiceFailedResponse(sluice, insideDoor, p)
                                          . Sluice(outsideStuck = true)
                                        )
                        )
                     );

init
  hide({
    cStatusUpdateRequest,
    cStatusUpdateResponse,
    cMoveRequest,
    cMoveResponse,
    cMoveCancel,
    cSluiceRequest,
    cSluiceResponse,
    cSluiceFailedResponse,
    cSluiceMoveDone
  },
  allow({
    move,
    closeDoor, openDoor,
    doorStuck,
    vacuum, deVacuum,
    stopPumping,
    readAirPressure,
    beginProject, endProject,
    detectInputWafer,

    cStatusUpdateRequest,
    cStatusUpdateResponse,
    cMoveRequest,
    cMoveResponse,
    cMoveCancel,
    cSluiceRequest | cMoveRequest,
    cSluiceRequest | cMoveRequest | cSluiceStuck,
    cSluiceResponse,
    cSluiceFailedResponse,
    cSluiceMoveDone | cMoveResponse
  },
  comm({
    sStatusUpdateRequest  | rStatusUpdateRequest  -> cStatusUpdateRequest,
    sStatusUpdateResponse | rStatusUpdateResponse -> cStatusUpdateResponse,
    sMoveRequest              | rMoveRequest              -> cMoveRequest,
    sMoveResponse             | rMoveResponse             -> cMoveResponse,
    sMoveCancel               | rMoveCancel               -> cMoveCancel,
    sSluiceRequest            | rSluiceRequest            -> cSluiceRequest,
    sSluiceResponse           | rSluiceResponse           -> cSluiceResponse,
    sSluiceFailedResponse     | rSluiceFailedResponse     -> cSluiceFailedResponse,
    sSluiceMoveDone           | rSluiceMoveDone           -> cSluiceMoveDone,
    sSluiceStuck              | rSluiceStuck              -> cSluiceStuck
  },
    WaferTracker(placesEmpty, placesFalse) || RobotOutside(false, 0, false) || Sluice(sluice1, false, false, false, false) || RobotInside || ProjectorRobot || Sluice(sluice2, false, false, false, false)
  )));
